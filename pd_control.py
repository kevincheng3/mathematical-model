import numpy as np
from mujoco_py import MjSim, MjViewer, load_model_from_path

import numpy as np
from scipy.spatial.transform import Rotation as R
from math import cos, sin
from scipy.optimize import minimize


def forward(theta0, theta1, theta2, theta3):
    l = 0.03
    y = (l * cos(theta1) + l * cos(theta1+theta2) + l * cos(theta1 + theta2 + theta3)) * cos(theta0)
    x = (l * cos(theta1) + l * cos(theta1+theta2) + l * cos(theta1 + theta2 + theta3)) * sin(theta0)
    z = l * sin(theta1) + l * sin(theta1+theta2) + l * sin(theta1 + theta2 + theta3)
    return np.array([x, y, z])

def cost(x):
    "Ideal contact point location"
    desired_pos = np.array([0.02, -0.02, 0.07])
    "Fingertip position through feedforward kinematics"
    pos = forward(x[0], x[1], x[2], x[3])
    "cost function"
    cost = np.linalg.norm(desired_pos - pos)
    # print(pos)
    return cost

x0 = np.array([-0.35, 1.3, 0.6,0.3])
res = minimize(cost, x0)  


def torque_computed(current_pos, current_vel, desired_pos, desired_vel, kp=20, kv=0.01 ):
    pos_torque = - kp * (current_pos - desired_pos)
    vel_torque = - kv * (current_vel - desired_vel)
    return pos_torque + vel_torque

def jacobian(id, theta0, theta1, theta2, theta3):
    l = 0.03
    dot_x = np.array([-(l * cos(theta1) + l * cos(theta1+theta2) + l * cos(theta1 + theta2 + theta3)) * sin(theta0), 
            -l * cos(theta0) * sin(theta1), -l * cos(theta0) * sin(theta1 +theta2), -l * cos(theta0) * sin(theta1 +theta2 + theta3)])
    dot_y= np.array([(l * cos(theta1) + l * cos(theta1+theta2) + l * cos(theta1 + theta2 + theta3)) * cos(theta0), 
            -l * sin(theta0) * sin(theta1), -l * sin(theta0) * sin(theta1 +theta2), -l * sin(theta0) * sin(theta1 +theta2 + theta3)])
    dot_z= np.array([0 , l * cos(theta1), l * cos(theta1 +theta2), l * cos(theta1 +theta2 + theta3)])
    if id ==0:
        return np.array([dot_x, dot_y, dot_z])
    elif id == 1:
        return np.array([-dot_y, dot_x, dot_z])
    elif id == 2:
        return np.array([-dot_x, -dot_y, dot_z])
    elif id == 3:
        return np.array([dot_y, -dot_x, dot_z])

class Controller():
    # The max speed.
    MAX_SPEED = 1.0

    # The minimum speed.
    MIN_SPEED = 0.0
    SPEED_CHANGE_PERCENT = 0.2

    def __init__(self, sim) -> None:
        super().__init__()
        self.sim = sim

    def apply_torque(self, id, desired_pos, desired_vel, kp=20, kv=0.01 ):
        "pd controller"
        pos_torque = - kp * (self.sim.data.qpos[id+3] - desired_pos)
        vel_torque = - kv * (self.sim.data.qvel[id+3] - desired_vel)

        self.sim.data.ctrl[id] = pos_torque + vel_torque


    def apply_torque_jacobian(self, id, desired_pos, desired_vel, fd_torque = 0, kp=20, kv=0.01 ):
        "fd_torque is generated by the contact force "
        pos_torque = - kp * ( - desired_pos)
        vel_torque = - kv * (self.sim.data.qvel[id+3] - desired_vel)

        self.sim.data.ctrl[id] = pos_torque + vel_torque + fd_torque

    

def main():
    model = load_model_from_path("./planar_box_pd.xml")
    sim = MjSim(model)
    hand = Controller(sim)
    viewer = MjViewer(sim)    

    viewer.cam.distance = 0.5
    viewer.cam.azimuth = 0
    viewer.cam.elevation = -20
    viewer._paused = 1

    x0 = np.array([-0.35, 1.3, 0.6,0.3])
    res = minimize(cost, x0)  

    delta_t = 0.0002 # timestep
    n_inters = 999
    n_fingers = 4 # numbers of fingers
    object_v = 0.05 # velocity of object
    finger_f = 0.1 # contact force of finger

    for i in range (n_inters+1):
        for j in range(n_fingers):
            hand.apply_torque(1 + 4*j, res.x[1] /  n_inters * i, 0, kp=10, kv = 0.01)
            hand.apply_torque(2 + 4*j, res.x[2] /  n_inters * i, 0)
            hand.apply_torque(3 + 4*j, res.x[3] /  n_inters * i, 0)            
            if j % 2 ==0:
                hand.apply_torque(0 + 4*j, -res.x[0] / n_inters * i, 0, kp=10, kv = 0.01)
            else:
                hand.apply_torque(0 + 4*j, res.x[0] / n_inters * i, 0, kp=10, kv = 0.01)

        sim.step()
        viewer.render()

    for i in range(n_inters+1):
        for j in range(n_fingers):
            hand.apply_torque(1 + 4 * j, res.x[1], 0, kp=10, kv = 0.01)
            hand.apply_torque(2 + 4 * j, res.x[2], 0)
            hand.apply_torque(3 + 4 * j, res.x[3], 0)            
            if j % 2 ==0:
                hand.apply_torque(0 + 4 * j, -res.x[0], 0, kp=10, kv = 0.01)
            else:
                hand.apply_torque(0 + 4 * j, res.x[0], 0, kp=10, kv = 0.01)

        sim.step()
        viewer.render()


    for i in range(100000):
        v = np.array([object_v * cos(i / (100 * np.pi)) , object_v * sin(i / (100 * np.pi)), 0.0])
        # print(v)
        theta = np.zeros((n_fingers, 4))
        for j in range(n_fingers):
            theta = np.linalg.pinv(jacobian(j, sim.data.qpos[3 + 4 * j], sim.data.qpos[4 + 4 * j], sim.data.qpos[5  + 4 * j], sim.data.qpos[6  + 4 * j])).dot(v)
            for k in range(4):
                if j ==0:
                    f = np.array([-finger_f, 0, 0])
                elif j ==1:
                    f = np.array([0, -finger_f, 0])
                elif j ==2:
                    f = np.array([finger_f, 0, 0])
                elif j ==3:
                    f = np.array([0, finger_f, 0])

                feedforward_torque = jacobian(j, sim.data.qpos[3 + 4 * j], sim.data.qpos[4 + 4 * j], sim.data.qpos[5  + 4 * j], sim.data.qpos[6  + 4 * j]).T.dot(f)

                if k == 0:
                    hand.apply_torque_jacobian(k + 4 * j, theta[k] * delta_t, theta[k], feedforward_torque[k], kp=10, kv = 0.01)
                else: 
                    hand.apply_torque_jacobian(k + 4 * j, theta[k] * delta_t, theta[k], feedforward_torque[k])


        sim.step()
        viewer.render()

if __name__ == "__main__":
    main()